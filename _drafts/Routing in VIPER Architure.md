---
layout: post
title: "Routing in VIPER Architure"
date: 2018-03-28
---

## Introduction

Blalflf  



## The Function of a Router

The primary function of a Router is to manage the display of scenes according to a set of behaviours such as stacking, direct access or serial access. 

This functionality is provided in iOS by specialized ViewControllers, such as NavigationControllers, TabBarControllers and PageViewControllers. Each of these manages the display and life cycle of a set of child ViewControllers.

The secondary function of a router is pass system state between scenes.

## Routers in VIPER

When using VIPER, each scene is implemented with a ViewController, a Presenter and a UseCase. This is known as a VIP stack or module. A router is simply another module - one that knows how to display child scenes by stacking, tabbing, paging, menu-ing or some custom sequence. 

A module's router is not another class of the module - it is the parent module. 

A Router in VIPER is simply a NavigationController, a TabbarController, a PageViewController, or any other custom ViewController that knows how to manage the display of their VIPER children.

### The Presenter Communicates with the Router

The first rule of VIPER is that all events received by a view controller must be passed directly to its presenter. The presenter then makes the decision to communicate with its Use Case or its Router. When the event is received by the presenter from the Use Case, it also has to make the decision to send the event to the ViewController or to the Router.

In VIPER, The ViewController never communicates with its router, only the presenter does. The ViewController never changes a scene directly unless it is, itself, a Router changing scenes of its child ViewControllers.

### The Router's VIP Stack

A router has its own VIP stack: A ViewController, a Presenter and a UseCase. All of their roles are the usual ones.

#### The ViewController 

The role of a Routerâ€™s ViewController is the same as usual: to change scenes by changing the visible ViewController in some way. 
In VIPER, a custom Router will send all UI events to the Presenter. If the ViewController is one suppled by the iOS SDK, the events from the UI are already consumed by the viewController implementation, so the delegates . 

#### The Presenter

FIXME: The role of the Presenter is the same as any other presenter: to consume events sent to the ViewController. When implementing a custom Router, such as one driven by menus or tabs, or a custom sequence, the messages from the UI are be passed directly to the presenter as usual. 

The majority of the messages which the Presenter responds to are routing messages that come from the Router's child modules. These messages originate from events generated by the user of the child modules.

The Presenter may simply translate the message and send it to its output (the originating ViewController) or it can pass the message to the Router's UseCase. The UseCase will, generally, initialize shared data for the child modules, translate the message and send it to its output.  In the majority of cases, the Router does not need to implement a UseCase.

In the case of UIKit supplied Routers, the delegates are used to initialize the child view controllers after they are instantiated. In the case of custom Routers the child ViewControllers are instantiated by the custom ViewController. 

### Router Messages are implemented by the Router's Presenter

There are cases that the Routers presenter must contact its Interactor to make a decision based on system state



In many cases the result of a child VIPER stack has to be presented by the parent. it is much simpler to send  

because you may have to send back presentation models that the presenter must convert to view models (see TodoListPresenter.eventItemSelected())

## Challenges

### Maintaining the Utility of Storyboards

### Passing Data between Controllers

#### Data Selected by another View Controller

#### Connecting the Presenter to the Router

#### Data Shared By Multiple View Controllers

Normally fresh data comes from the entity gateway which is only known by the interactor. But how should data be passed from interactor to interactor?

### Going against the grain

#### Allocating class responsibilities appropriately

#### Alternative to the view controller delegate pattern

#### Additional behaviour for the Nav controller subclass 



## App Overview

Here is a screen shot of the top of the display:

![ReportListDemoTop](/Assets/ReportListDemoTop.png)

Here is the middle :

![ReportListDemoMiddle](/Assets/ReportListDemoMiddle.png)









 I decided the best way to proceed was to generate the output into a separate structure to drive the display. 



```
public class TransactionModel {
	String group;
	String date;
	String description;
	String amount;
	String debit;
}
```

