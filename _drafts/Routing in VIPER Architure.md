---
layout: post
title: "Routing in VIPER Architure"
date: 2018-03-28
---

## Introduction

Blalflf  



## The Function of a Router

The primary function of a Router is to manage the display of a set of scenes using a pattern such as stacking, direct access or serial access. 

Router functionality is provided in iOS by specialized ViewControllers, such as Navigation-, TabBar- and PageView-Controllers. Each of these manages the display and life cycle of a set of child ViewControllers. There is also the possibility of creating custom Routers which implement other useage patterns such as menu or custom tab access, or a domain-defined sequence.

Another function of a Router is to maintain system state for child modules.

The main difference between a VIPER Router and a UIKit router is that the routing code is located where it is supposed to be: in the Router - not the child view controllers

## Routers in VIPER

In VIPER, a Router is just another VIP-stack, and is implemented with a ViewController, a Presenter and a UseCase.  A router is simply another module - one that knows how to display child scenes using a pattern. 

A module's router is not another class of the module - it is the parent module. 

A Router ViewController can be inherited from a NavigationController, a TabBarController, or a  PageViewController. A Custom Router will inherit from a plain ViewController to create a *container*  ViewController.

### The Presenter Communicates with the Router

A major rule of VIPER is that any event received by a ViewController must be forwarded directly to its Presenter. The Presenter forwards the event to either its Use Case or its Router. 

When the output is received by the Presenter from the Use Case, it might send the output to the Router instead of the ViewController. An example of this is when a scene exits.

The result is that a ViewController never communicates with a router, only the presenter does.

### The Router's VIP Stack

A router has its own VIP stack: A ViewController, a Presenter and a UseCase. All of their roles are the usual ones.

#### The ViewController 

The role of a Router's ViewController is the same it would be without VIPER: to do the work of changing scenes. 

When the Router's ViewController is a subclass of a NavigationController or TabBarController, the events from the UI are already consumed by the controller itself, so their delegates must be used to monitor events. In particular, the router injects its Presenter into the child view controllers in the delegate before they are displayed.

When a Navigation- or TabBarController is associated with a storyboard, the child's `perform(segue:)` calls are called from the parents implementation and the `prepareFor(segue:)` override is implemented as an extension within the NavigationController's file. This override is just a dance because the Navigation Controller actually implements the Segue.

In the case of a custom Routing ViewController , child ViewControllers are instantiated by the custom ViewController as normal, and the perform(segue:) and prepareFor(segue:) are implemented by the custom ViewController

In VIPER, a custom Router will send all UI events to the Presenter,  as usual.

#### The Presenter

The role of the Presenter is the same as any other presenter: to consume events sent to the ViewController. When implementing a custom Router, such as one driven by menus or tabs, or a custom sequence, the messages from the UI are passed directly to the presenter as usual. 

The majority of the messages which the Presenter responds to are routing messages that come from the Router's child modules. These messages originate from events generated by the user of the child modules.

The Presenter may simply translate the message and send it to its output or it can pass the message to the Router's UseCase. 

The Presenter might instantiate state data models that will be injected into all child UseCases.

#### The UseCase

The Router's UseCase initializes data that will be shared by all child UseCases. Usually this occurs when the viewLoaded event is received.  Most of the time, the Router does not need to implement a UseCase.

#### Why are Router Messages implemented by the Router's Presenter?

The ViewController in VIPER only forwards inbound events and Displays the results of those events.

Router messages start as events in a child ViewController. All events received by a ViewController are forwarded to it's Presenter, so all Router messages are sent to the Presenter anyway.

In some cases the Router must refer to its UseCase to make a decision based on system state - a message would have to be sent through two layers just to get to the UseCase. 

In practice, implementing the routing messages in the Presenter is the right choice. 

## Changing Scenes 

### Who's Responsibility

In VIPER, initiation of a scene change is the responsibility of the parent (just like in Android). iOS has an opinion about how scene change should be initiated. 

In iOS, a ViewController is given access to its parent via one of the navigation-, tabBar- or splitView-Controller properties. This allows the child to know about and to control the behaviour of parent. In the case of navigation or splitView, the control is used to push a new controller on top. This leads to dependency issues, since this added responsibility ties the child to a predetermined environment defined by presentation-style or system state. 

iOS tries to overcome this problem for navigation and splitView by introducing the `show(:sender:)` and `showDetail(:sender:)` methods. At least these methods allow a child of parent to not be concerned about which stacking environment they are in. 

In a VIPER architecture child ViewControllers make no assumptions about their environment and as such are available for use in any role, whether defined by presentation-style or system state.

### Storyboards

Storyboards provide a number of advantages other than simply reducing the need to hand-code view layouts. Storyboards document the layout and flow of the app. When a Segue instantiates a ViewController, it calls `awakeFromNib()`, which is used to configure the VIP stack and can perform post-IB injections. 

In most cases, using Storyboards is not counter to the architecture of a VIPER Router. The only unusual situation is when using NavigationControllers. 

#### NavigationControllers

In a Storyboard, the "relationship" Segue from a parent points to its first-displayed child. In the case of Navigation- or SplitView-Controllers, the next Segue points to the next-displayed sibling scene. 

Using a Segue and in turn the `show*(:sender:)` methods, a child ViewController of a Navigation- or SplitView-Controller by-passes the parent when initiating a sibling scene - or so it seems. The Segue actually calls the parent controller's `pushViewController(_:animated:)` method.

The problem for a VIPER Router implementation is that a Segue's source ViewController is the previous sibling, not the parent, so the parent's `prepareFor(segue:)` is not called - but the previous sibling's is called.

The solution to this is to create a extension in the parent ViewController's file and override `prepareFor(segue:)` there. Here the NavController's `showItem(id: String)` initates a Segue on the topmost child with an `id` parameter. The `prepare(for segue: UIStoryboardSegue, sender: Any?)`  of the child is used to inject the `id` into the child's sibling.

```Swift
extension SomeRouterNavController: SomeRouterPresenterOutput {
        
    func showItem(id: String) {

        let identifier = SomeRouterSegue.showSome.rawValue
        viewControllers.first?.performSegue(withIdentifier: identifier, sender: id)
    }
}
```

```Swift
extension SomeListViewController {
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        
        let viewController = segue.destination as! SomeItemViewController
        let id = sender as! String
        viewController.id = id
    }
}
```



### Passing Data between Controllers

#### Data Selected by another View Controller

#### Connecting the Presenter to the Router

#### Data Shared By Multiple View Controllers

Normally fresh data comes from the entity gateway which is only known by the interactor. But how should data be passed from interactor to interactor?

### Going against the grain

#### Allocating class responsibilities appropriately

#### Responses from other Scenes (Alternative to the view controller delegate pattern)

There are also cases where a presentation model must be prepared for an older sibling that the presenter must convert to view models (see TodoListPresenter.eventItemSelected())

## 

#### Additional behaviour for the Nav controller subclass 



## App Overview

Here is a screen shot of the top of the display:

![ReportListDemoTop](/Assets/ReportListDemoTop.png)

Here is the middle :

![ReportListDemoMiddle](/Assets/ReportListDemoMiddle.png)









 I decided the best way to proceed was to generate the output into a separate structure to drive the display. 



```
public class TransactionModel {
	String group;
	String date;
	String description;
	String amount;
	String debit;
}
```

