---
layout: post
title: "Routing in VIPER Architure"
date: 2018-03-28
---

## Introduction

Blalflf  



## The Function of a Router

The primary function of a Router is to manage the display of scenes according to a set of behaviours such as stacking, direct access or serial access. 

This functionality is provided in iOS by specialized ViewControllers, such as NavigationControllers, TabBarControllers and PageViewControllers. Each of these manages the display and life cycle of a set of child ViewControllers.

The secondary function of a router is pass system state between scenes.

## Routers in VIPER

When using VIPER, each scene is implemented with a ViewController, a Presenter and a UseCase. This is known as a VIP stack or module. A router is simply another module - one that knows how to display child scenes by stacking, tabbing, paging, menu-ing or some custom sequence. 

A module's router is not another class of the module - it is the parent module. 

A Router in VIPER is simply a NavigationController, a TabbarController, a PageViewController, or any other custom ViewController that knows how to manage the display of their VIPER children.

### The Presenter Communicates with the Router

The first rule of VIPER is that all events received by a view controller must be passed directly to its presenter. The presenter then makes the decision to communicate with its Use Case or its Router. When the event is received by the presenter from the Use Case, it also has to make the decision to send the event to the ViewController or to the Router.

In VIPER, The ViewController never communicates with its router, only the presenter does. The ViewController never changes a scene directly unless it is, itself, a Router changing scenes of its child ViewControllers.

### The Router's VIP Stack

A router has its own VIP stack: A ViewController, a Presenter and a UseCase. All of their roles are the usual ones.

#### The ViewController 

The role of a Routerâ€™s ViewController is the same it would be without VIPER: to change scenes by changing the visible ViewController in some way. 
In VIPER, a custom Router will send all UI events to the Presenter. If the ViewController is a subclass of a NavigationController or TabBarController, the events from the UI are already consumed by the controller's implementation, so their delegates are used to pick up events. 

In the case of UIKit supplied Routers, the delegates are used to initialize the child view controllers after they are instantiated. In the case of custom ViewControllers Routers, the child ViewControllers are instantiated by the custom ViewController.

#### The Presenter

The role of the Presenter is the same as any other presenter: to consume events sent to the ViewController. When implementing a custom Router, such as one driven by menus or tabs, or a custom sequence, the messages from the UI are passed directly to the presenter as usual. 

The majority of the messages which the Presenter responds to are routing messages that come from the Router's child modules. These messages originate from events generated by the user of the child modules.

The Presenter may simply translate the message and send it to its output or it can pass the message to the Router's UseCase. 

The Presenter should instantiate state data models that will be injected into all child UseCases.

#### The UseCase

The Router's UseCase initializes data that will be shared by all child UseCases. Usually this happens when the viewLoaded event is received.  In the majority of cases, the Router does not need to implement a UseCase.

#### Why are Router Messages implemented by the Router's Presenter?

Given that the first rule of VIPER states that all user events received by a ViewController must be sent to the Presenter simply leads to the fact that if the Router's ViewController implemented the router messages, those messages would all be sent directly to the Presenter anyway.

Notwithstanding that, there are cases where the Router must refer to its UseCase to make a decision based on system state - this would mean that the message would have to be sent through two layers just to make a decision. Remember that is si the presenter that is responsible for making the decisions regarding whether messages are forwarded to the Router, UseCase or ViewController.

It turns out in practice, that implementing the routing messages in the Presenter is the right choice. 

## Challenges

### Maintaining the Utility of Storyboards

### Passing Data between Controllers

#### Data Selected by another View Controller

#### Connecting the Presenter to the Router

#### Data Shared By Multiple View Controllers

Normally fresh data comes from the entity gateway which is only known by the interactor. But how should data be passed from interactor to interactor?

### Going against the grain

#### Allocating class responsibilities appropriately

#### Responses from other Scenes (Alternative to the view controller delegate pattern)

There are also cases where a presentation model must be prepared for an older sibling that the presenter must convert to view models (see TodoListPresenter.eventItemSelected())

## 

#### Additional behaviour for the Nav controller subclass 



## App Overview

Here is a screen shot of the top of the display:

![ReportListDemoTop](/Assets/ReportListDemoTop.png)

Here is the middle :

![ReportListDemoMiddle](/Assets/ReportListDemoMiddle.png)









 I decided the best way to proceed was to generate the output into a separate structure to drive the display. 



```
public class TransactionModel {
	String group;
	String date;
	String description;
	String amount;
	String debit;
}
```

