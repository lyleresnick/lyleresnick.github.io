---
layout: post
title: "Solving a Complex Android Recycler View"
date: 2016-11-21
---

## Report Table Demo

I was working with the Android team at the Bank, and I was tasked with creating a display of Account Data for all kinds of accounts. One of the subtasks was to display Credit Card Transactions in a List on the lower 2/3 of of a Scene. 

The input consisted of two simple streams of transactions: Posted and Authorized . Although the data streams where not identical in format, each one contained identical data. Each transaction record consisted of a Date, a Description, an amount,  and a debit indicator.

Posted Transactions would be displayed first. The total of each stream would be displayed in a row at the end of each transaction stream. The Transaction type would be displayed before each stream. Transaction rows were to be grouped and displayed by Date. The Date would preceed each date group. Each Date group and Total row were to be banded with alternating colours.

Here is a screen shot of the top of the display:

![ReportListDemoTop](/Assets/ReportListDemoTop.png)

Here is the middle :

![ReportListDemoMiddle](/Assets/ReportListDemoMiddle.png)

As you might have noticed, the relationship between the input and output is not one to one. There are extra rows for Titles, Subtitles, Totals, and as you will see, Sub-footers and Error Messages. I decided the best way to proceed was to generate the output into a separate structure to drive the display. 

Android uses the concept of an adapter to act as a datasource for a ListView. Unlike a UITableViewDataSource, which is a protocol, an Adapter for a Listview must be implemented as a separate class. This is because ListView adapters must be inherited from an *abstract* class. 

In iOS it is customary to implement the UITableviewDataSource by placing the implementation code in the ViewController that owns the TableView. This leads to bloated ViewControllers, not to mention the mixing of concerns. By placing the data source code in a separate Adapter class, the code size of the owning Activity of Fragment is reduced.  

On top of these details there the requirement to use the RecylerView. This would involve the management of ViewHolders.

The purpose of demonstrating the Android version is to show what happens when the table Datasource function is moved from the Fragment, which is standing in for a ViewController, to an Adapter. Here, the fragment has a number of responsibilities:

1. initialize the views,
2. transform the transaction rows into a form appropriate for display
3. make the display rows available through an adapter 

There is too much going on here. The fragment's only responsibility should be to initialize the views. The fragment has too many responsibilities. I will discuss this aspect in a future post.

In the demonstration code each transaction looks like this: 

```
public class TransactionModel {
	String group;
	String date;
	String description;
	String amount;
	String debit;
}
```

This model represents the data model that the service layer would deliver.

I reuse the `appendTransactions` function, once for each input steam. The function is written so that its structure mimics the structure of the input data combined with the output data. I will talk more about how I derived this structure in a future post.

The adapter's messages are designed to capture the data generated by the transformation. The visual design of the  transaction list view, with its various headers and footers, drove the design of the transformation, which in turn drove the design of the messages. The messages represent a virtual output stream that the adapter will capture. The List, when notified to reload, sends messages to the adapter in order to retrieve the output of the transformation.  

So what are the responsibilities of the adapter? They are:

1. store the data passed in by the append messages,
2. provide the data to the `RecyclerView` 

Each append method allocates a `Row` model to store the data passed in and appends it to a list for persistence. The rows are then used as the backing store when responding to the messages sent by the `RecyclerView`. 

Data is provided to the `RecyclerView` by responding to  `getItemViewType`, `onCreateViewHolder`, `onBindViewHolder`, and `getItemCount` .The adapter has to provide a method to map the row data to a visual layout

Each row implements a row protocol (via an interface). Each Row stores its related layout type and is accessed by the  `getType`  protocol method. This provides a mapping from row to layout for `getItemViewType` . The type is passed to `onCreateViewHolder` to actually select the layout.

Each type of `ViewHolder` is responsible for transfering data from its kind of row to its kind of visual layout. Each viewHolder provides a method to perform the transfer called  `bind` .

When `onBindViewHolder` sends the  `bind` message,  the `ViewHolder` uses the dataset position to select the row to display

For those following from the iOS camp:

- `getItemCount` is analogous to `numberOfRowsInSection` 


- the result of `getItemViewType` is analogous to the identifier parameter of  `dequeueReusableCellWithIdentifier` 


- `onCreateViewHolder`is analogous to `dequeueReusableCellWithIdentifier` combined with registration


- the implementation of `onBindViewHolder` is whatever you do in `cellForRowAtIndexPath` after you call `dequeueReusableCellWithIdentifier` 

One might ask: why not place the code that transforms the rows into the adapter?. Well you could, but then you would a really massive adapter, instead of a really massive fragment. It would also remove the abstraction that the append methods provide, which in turn would make it very difficult to unit test. As we will see, It turns out that leaving the transformation code in the fragment is a good idea - one that can be taken further.

I want to mention that is is entirely possible that the adapter could have been implemented as an inner class. The Rows structure could have been owned by the Fragment. The transformation methods could have added the row types to the Rows structure directly. Implementing in this manner would have coupled the adapter code to the Fragent Code. 

 Using this antipattern:

- The Rows structure would have been owned by the Fragment. 
- The transformation methods would have added the row types to the Rows structure directly.

You can see an example of the use of inner classes in the adapter as currently implemented. All of the ViewHolders have access to the rowList. 



TODO: discuss - all code directly accessing the rowList, both creating and reading

By placing all of the adapter code inside the Fragment, you place a lot of responsibility leading to extremely tightly coupled to the Fragment Code. 

The objective of removing the List adapter code from the fragment encapsulates the data structures uses to back the List





Another reference my peer sent me was [CleanSwift ](http://clean-swift.com). This is another hat recently thrown into the Clean Mobile Architecture ring. 

